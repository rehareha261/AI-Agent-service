-- ===============================================
-- MIGRATION: AJOUT DES TABLES DE VALIDATION HUMAINE
-- Description: Ajoute le système "human in the loop" pour la validation des codes générés
-- Compatible avec la structure existante base2.sql
-- ===============================================

-- 1) TABLE DES DEMANDES DE VALIDATION HUMAINE
CREATE TABLE IF NOT EXISTS human_validations (
    human_validations_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    validation_id VARCHAR(100) UNIQUE NOT NULL, -- ID unique généré par l'application
    
    -- Références vers les entités existantes
    task_id BIGINT NOT NULL REFERENCES tasks(tasks_id) ON DELETE CASCADE,
    task_run_id BIGINT REFERENCES task_runs(tasks_runs_id) ON DELETE CASCADE,
    run_step_id BIGINT REFERENCES run_steps(run_steps_id) ON DELETE CASCADE,
    
    -- Informations de la tâche (dénormalisées pour performance)
    task_title VARCHAR(500) NOT NULL,
    task_description TEXT,
    original_request TEXT NOT NULL,
    
    -- Statut de validation
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    
    -- Code généré à valider
    generated_code JSONB NOT NULL, -- {"filename": "content", ...}
    code_summary TEXT NOT NULL,
    files_modified TEXT[] NOT NULL, -- Array des fichiers modifiés
    implementation_notes TEXT,
    
    -- Résultats des tests (si disponibles)
    test_results JSONB,
    
    -- Informations de la Pull Request
    pr_info JSONB, -- {"number": 123, "url": "...", "title": "..."}
    
    -- Métadonnées de validation
    workflow_id VARCHAR(255),
    requested_by VARCHAR(100) DEFAULT 'ai_agent',
    
    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- Date d'expiration de la demande
    
    CONSTRAINT human_validations_status_chk CHECK (
        status IN ('pending', 'approved', 'rejected', 'expired', 'cancelled')
    )
);

-- Index pour les validations
CREATE INDEX IF NOT EXISTS idx_human_validations_validation_id ON human_validations(validation_id);
CREATE INDEX IF NOT EXISTS idx_human_validations_task_id ON human_validations(task_id);
CREATE INDEX IF NOT EXISTS idx_human_validations_status ON human_validations(status);
CREATE INDEX IF NOT EXISTS idx_human_validations_expires_at ON human_validations(expires_at) WHERE expires_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_human_validations_created_at ON human_validations(created_at DESC);

-- Index composé pour les requêtes fréquentes
CREATE INDEX IF NOT EXISTS idx_human_validations_status_expires ON human_validations(status, expires_at);

-- 2) TABLE DES RÉPONSES DE VALIDATION HUMAINE
CREATE TABLE IF NOT EXISTS human_validation_responses (
    human_validation_responses_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    
    -- Référence vers la demande de validation
    human_validation_id BIGINT NOT NULL REFERENCES human_validations(human_validations_id) ON DELETE CASCADE,
    validation_id VARCHAR(100) NOT NULL, -- Dénormalisé pour performance
    
    -- Statut de la réponse
    response_status VARCHAR(50) NOT NULL,
    
    -- Feedback humain
    comments TEXT,
    suggested_changes TEXT,
    approval_notes TEXT,
    
    -- Informations du validateur
    validated_by VARCHAR(100),
    validated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Actions à prendre
    should_merge BOOLEAN NOT NULL DEFAULT FALSE,
    should_continue_workflow BOOLEAN NOT NULL DEFAULT TRUE,
    
    -- Métadonnées
    validation_duration_seconds INTEGER, -- Temps pris pour valider
    user_agent TEXT, -- Navigateur/interface utilisé
    ip_address INET, -- Adresse IP du validateur (optionnel)
    
    CONSTRAINT human_validation_responses_status_chk CHECK (
        response_status IN ('approved', 'rejected', 'expired', 'cancelled')
    )
);

-- Index pour les réponses
CREATE INDEX IF NOT EXISTS idx_human_validation_responses_validation_id ON human_validation_responses(validation_id);
CREATE INDEX IF NOT EXISTS idx_human_validation_responses_status ON human_validation_responses(response_status);
CREATE INDEX IF NOT EXISTS idx_human_validation_responses_validated_at ON human_validation_responses(validated_at DESC);
CREATE INDEX IF NOT EXISTS idx_human_validation_responses_validated_by ON human_validation_responses(validated_by);

-- 3) TABLE DES ACTIONS POST-VALIDATION (MERGE, ETC.)
CREATE TABLE IF NOT EXISTS validation_actions (
    validation_actions_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    
    -- Référence vers la validation
    human_validation_id BIGINT NOT NULL REFERENCES human_validations(human_validations_id) ON DELETE CASCADE,
    validation_id VARCHAR(100) NOT NULL,
    
    -- Type d'action
    action_type VARCHAR(50) NOT NULL, -- 'merge', 'reject_pr', 'update_monday', etc.
    action_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    
    -- Détails de l'action
    action_data JSONB, -- Données spécifiques à l'action
    result_data JSONB, -- Résultat de l'action
    
    -- Informations de merge (si applicable)
    merge_commit_hash VARCHAR(100),
    merge_commit_url VARCHAR(500),
    
    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    
    -- Erreurs
    error_message TEXT,
    retry_count INTEGER NOT NULL DEFAULT 0,
    
    CONSTRAINT validation_actions_type_chk CHECK (
        action_type IN ('merge_pr', 'reject_pr', 'update_monday', 'cleanup_branch', 'notify_user')
    ),
    CONSTRAINT validation_actions_status_chk CHECK (
        action_status IN ('pending', 'in_progress', 'completed', 'failed', 'cancelled')
    )
);

-- Index pour les actions
CREATE INDEX IF NOT EXISTS idx_validation_actions_validation_id ON validation_actions(validation_id);
CREATE INDEX IF NOT EXISTS idx_validation_actions_type_status ON validation_actions(action_type, action_status);
CREATE INDEX IF NOT EXISTS idx_validation_actions_created_at ON validation_actions(created_at DESC);

-- ===============================================
-- TRIGGERS ET FONCTIONS POUR LA VALIDATION HUMAINE
-- ===============================================

-- Fonction pour marquer les validations expirées
CREATE OR REPLACE FUNCTION mark_expired_validations() RETURNS INTEGER AS $$
DECLARE
    expired_count INTEGER;
BEGIN
    UPDATE human_validations 
    SET status = 'expired', 
        updated_at = NOW()
    WHERE status = 'pending' 
      AND expires_at IS NOT NULL 
      AND expires_at < NOW();
    
    GET DIAGNOSTICS expired_count = ROW_COUNT;
    
    -- Log l'opération
    IF expired_count > 0 THEN
        INSERT INTO application_logs (level, component, message, metadata)
        VALUES ('INFO', 'human_validation', 'Marked expired validations', 
                jsonb_build_object('expired_count', expired_count));
    END IF;
    
    RETURN expired_count;
END;
$$ LANGUAGE plpgsql;

-- Fonction trigger pour synchroniser le statut de validation
CREATE OR REPLACE FUNCTION sync_validation_status() RETURNS TRIGGER AS $$
BEGIN
    -- Quand une réponse est créée, mettre à jour le statut de la validation
    UPDATE human_validations 
    SET status = NEW.response_status,
        updated_at = NOW()
    WHERE human_validations_id = NEW.human_validation_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Créer le trigger
DO $$ BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_trigger WHERE tgname = 'sync_validation_status_trigger'
    ) THEN
        CREATE TRIGGER sync_validation_status_trigger
        AFTER INSERT ON human_validation_responses
        FOR EACH ROW EXECUTE FUNCTION sync_validation_status();
    END IF;
END $$;

-- Fonction pour calculer les statistiques de validation
CREATE OR REPLACE FUNCTION get_validation_stats() RETURNS TABLE (
    total_validations BIGINT,
    pending_validations BIGINT,
    approved_validations BIGINT,
    rejected_validations BIGINT,
    expired_validations BIGINT,
    avg_validation_time_minutes NUMERIC,
    urgent_validations BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_validations,
        COUNT(*) FILTER (WHERE status = 'pending') as pending_validations,
        COUNT(*) FILTER (WHERE status = 'approved') as approved_validations,
        COUNT(*) FILTER (WHERE status = 'rejected') as rejected_validations,
        COUNT(*) FILTER (WHERE status = 'expired') as expired_validations,
        ROUND(AVG(
            CASE 
                WHEN hvr.validated_at IS NOT NULL AND hv.created_at IS NOT NULL
                THEN EXTRACT(EPOCH FROM (hvr.validated_at - hv.created_at)) / 60.0
                ELSE NULL
            END
        ), 2) as avg_validation_time_minutes,
        COUNT(*) FILTER (
            WHERE status = 'pending' 
              AND expires_at IS NOT NULL 
              AND expires_at < NOW() + INTERVAL '1 hour'
        ) as urgent_validations
    FROM human_validations hv
    LEFT JOIN human_validation_responses hvr ON hv.human_validations_id = hvr.human_validation_id
    WHERE hv.created_at >= NOW() - INTERVAL '30 days'; -- Stats des 30 derniers jours
END;
$$ LANGUAGE plpgsql;

-- ===============================================
-- VUES POUR L'INTERFACE D'ADMINISTRATION
-- ===============================================

-- Vue pour le dashboard des validations
CREATE OR REPLACE VIEW validation_dashboard AS
SELECT 
    hv.human_validations_id,
    hv.validation_id,
    hv.task_title,
    hv.status,
    hv.created_at,
    hv.expires_at,
    CASE 
        WHEN hv.expires_at IS NOT NULL AND hv.expires_at < NOW() + INTERVAL '1 hour' 
        THEN TRUE 
        ELSE FALSE 
    END as is_urgent,
    CASE 
        WHEN hv.test_results IS NOT NULL AND (hv.test_results->>'success')::boolean = FALSE
        THEN TRUE
        ELSE FALSE
    END as has_test_failures,
    array_length(hv.files_modified, 1) as files_count,
    hv.pr_info->>'url' as pr_url,
    t.priority,
    t.repository_url,
    hvr.validated_by,
    hvr.validated_at,
    hvr.comments as validation_comments
FROM human_validations hv
JOIN tasks t ON hv.task_id = t.tasks_id
LEFT JOIN human_validation_responses hvr ON hv.human_validations_id = hvr.human_validation_id
ORDER BY 
    CASE WHEN hv.status = 'pending' THEN 0 ELSE 1 END,
    CASE 
        WHEN hv.expires_at IS NOT NULL AND hv.expires_at < NOW() + INTERVAL '1 hour' 
        THEN 0 
        ELSE 1 
    END,
    hv.created_at DESC;

-- Vue pour l'historique des validations
CREATE OR REPLACE VIEW validation_history AS
SELECT 
    hv.validation_id,
    hv.task_title,
    hv.status,
    hv.created_at,
    hv.expires_at,
    hvr.response_status,
    hvr.validated_by,
    hvr.validated_at,
    hvr.validation_duration_seconds,
    va.action_type,
    va.action_status,
    va.merge_commit_hash,
    t.repository_url,
    t.priority
FROM human_validations hv
JOIN tasks t ON hv.task_id = t.tasks_id
LEFT JOIN human_validation_responses hvr ON hv.human_validations_id = hvr.human_validation_id
LEFT JOIN validation_actions va ON hv.human_validations_id = va.human_validation_id
WHERE hv.status != 'pending'
ORDER BY hv.created_at DESC;

-- ===============================================
-- MISE À JOUR DES CONTRAINTES ET PERMISSIONS
-- ===============================================

-- Ajouter le nettoyage des validations expirées à la fonction de nettoyage existante
CREATE OR REPLACE FUNCTION cleanup_old_logs() RETURNS void AS $$
BEGIN
    -- Nettoyage existant
    DELETE FROM webhook_events WHERE received_at < NOW() - INTERVAL '6 months';
    DELETE FROM application_logs WHERE ts < NOW() - INTERVAL '3 months';
    
    -- Nouveau: nettoyer les anciennes validations
    DELETE FROM human_validations WHERE created_at < NOW() - INTERVAL '3 months';
    DELETE FROM validation_actions WHERE created_at < NOW() - INTERVAL '3 months';
    
    -- Marquer les validations expirées
    PERFORM mark_expired_validations();
END;
$$ LANGUAGE plpgsql;

-- ===============================================
-- COMMENTAIRES ET DOCUMENTATION
-- ===============================================

COMMENT ON TABLE human_validations IS 'Demandes de validation humaine pour les codes générés par l''IA';
COMMENT ON TABLE human_validation_responses IS 'Réponses des validateurs humains (approbation/rejet)';
COMMENT ON TABLE validation_actions IS 'Actions effectuées suite à la validation (merge, etc.)';

COMMENT ON COLUMN human_validations.validation_id IS 'ID unique généré par l''application pour tracking';
COMMENT ON COLUMN human_validations.generated_code IS 'Code généré au format JSON {"filename": "content"}';
COMMENT ON COLUMN human_validations.files_modified IS 'Array PostgreSQL des fichiers modifiés';
COMMENT ON COLUMN human_validations.expires_at IS 'Date limite pour la validation (24h par défaut)';

COMMENT ON FUNCTION mark_expired_validations() IS 'Marque automatiquement les validations expirées';
COMMENT ON FUNCTION get_validation_stats() IS 'Retourne les statistiques de validation pour le dashboard';

COMMENT ON VIEW validation_dashboard IS 'Vue optimisée pour l''interface d''administration des validations';
COMMENT ON VIEW validation_history IS 'Historique complet des validations avec actions associées'; 