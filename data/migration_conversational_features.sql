-- ===============================================
-- MIGRATION: Ajout Fonctionnalités Conversationnelles
-- Date: 2025-10-12
-- Description: Ajout des tables manquantes pour un agent IA complet
-- Auteur: AI-Agent Analysis
-- Version: 1.0
-- ===============================================

-- NOTE: Ce script contient les migrations recommandées après analyse
-- Vous pouvez modifier/commenter les sections selon vos besoins

BEGIN;

-- ===============================================
-- 1. TABLE DES UTILISATEURS SYSTÈME
-- ===============================================
-- Description: Gestion des utilisateurs avec quotas IA et permissions
-- Priorité: HAUTE
-- Impact: Sécurité, gestion des coûts, traçabilité

CREATE TABLE IF NOT EXISTS system_users (
    user_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    monday_user_id BIGINT UNIQUE,
    email VARCHAR(255) UNIQUE,
    username VARCHAR(100),
    role VARCHAR(50) DEFAULT 'developer' CHECK (role IN ('admin', 'developer', 'viewer')),
    
    -- Quotas IA
    monthly_token_quota INTEGER DEFAULT 1000000,
    tokens_used_this_month INTEGER DEFAULT 0,
    monthly_reset_day INTEGER DEFAULT 1 CHECK (monthly_reset_day BETWEEN 1 AND 28),
    
    -- Préférences
    preferred_ai_provider VARCHAR(50) DEFAULT 'claude',
    preferred_model VARCHAR(100) DEFAULT 'claude-3-5-sonnet-20241022',
    notification_preferences JSONB DEFAULT '{
        "email_on_validation": true,
        "email_on_failure": true,
        "slack_notifications": false
    }'::jsonb,
    
    -- Métadonnées
    created_at TIMESTAMPTZ DEFAULT NOW(),
    last_active_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT TRUE,
    metadata JSONB DEFAULT '{}'::jsonb,
    
    CONSTRAINT tokens_used_within_quota CHECK (tokens_used_this_month <= monthly_token_quota)
);

CREATE INDEX idx_system_users_monday ON system_users(monday_user_id);
CREATE INDEX idx_system_users_email ON system_users(email);
CREATE INDEX idx_system_users_active ON system_users(is_active) WHERE is_active = TRUE;
CREATE INDEX idx_system_users_role ON system_users(role);

COMMENT ON TABLE system_users IS 'Utilisateurs du système avec quotas IA et préférences';
COMMENT ON COLUMN system_users.monthly_token_quota IS 'Nombre maximum de tokens IA autorisés par mois';
COMMENT ON COLUMN system_users.tokens_used_this_month IS 'Tokens consommés ce mois (réinitialisé automatiquement)';
COMMENT ON COLUMN system_users.role IS 'Rôle utilisateur: admin (tous droits), developer (créer/modifier), viewer (lecture seule)';


-- ===============================================
-- 2. TABLE DES PROMPTS/TEMPLATES IA
-- ===============================================
-- Description: Templates de prompts versionnés avec métriques de performance
-- Priorité: CRITIQUE
-- Impact: Maintenabilité, A/B testing, amélioration continue

CREATE TABLE IF NOT EXISTS ai_prompt_templates (
    template_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(255) UNIQUE NOT NULL,
    category VARCHAR(100) NOT NULL,  -- 'code_generation', 'analysis', 'debugging', 'update_detection', 'test_generation'
    version VARCHAR(20) NOT NULL,
    description TEXT,
    
    -- Contenu du prompt
    system_prompt TEXT,
    user_prompt_template TEXT NOT NULL,
    variables JSONB DEFAULT '[]'::jsonb,  -- Liste des variables attendues: ["task_description", "repo_url", "language"]
    example_usage TEXT,  -- Exemple d'utilisation pour documentation
    
    -- Configuration LLM recommandée
    model_recommended VARCHAR(100),
    temperature NUMERIC(3,2) DEFAULT 0.7 CHECK (temperature BETWEEN 0 AND 2),
    max_tokens INTEGER CHECK (max_tokens > 0),
    top_p NUMERIC(3,2) DEFAULT 1.0 CHECK (top_p BETWEEN 0 AND 1),
    frequency_penalty NUMERIC(3,2) DEFAULT 0.0,
    presence_penalty NUMERIC(3,2) DEFAULT 0.0,
    
    -- Gestion & Versioning
    is_active BOOLEAN DEFAULT TRUE,
    is_default BOOLEAN DEFAULT FALSE,  -- Template par défaut pour cette catégorie?
    parent_template_id BIGINT REFERENCES ai_prompt_templates(template_id),
    
    -- Statistiques de performance
    success_rate NUMERIC(5,2) CHECK (success_rate BETWEEN 0 AND 100),
    avg_quality_score NUMERIC(5,2) CHECK (avg_quality_score BETWEEN 0 AND 5),
    usage_count INTEGER DEFAULT 0,
    avg_execution_time_ms INTEGER,
    avg_cost_usd NUMERIC(10,6),
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    deprecated_at TIMESTAMPTZ,
    created_by_user_id BIGINT REFERENCES system_users(user_id),
    
    CONSTRAINT unique_template_name_version UNIQUE (name, version)
);

CREATE INDEX idx_prompt_templates_category ON ai_prompt_templates(category, is_active);
CREATE INDEX idx_prompt_templates_active ON ai_prompt_templates(is_active) WHERE is_active = TRUE;
CREATE INDEX idx_prompt_templates_default ON ai_prompt_templates(category, is_default) WHERE is_default = TRUE;
CREATE INDEX idx_prompt_templates_success ON ai_prompt_templates(success_rate DESC) WHERE is_active = TRUE;
CREATE INDEX idx_prompt_templates_created ON ai_prompt_templates(created_at DESC);

COMMENT ON TABLE ai_prompt_templates IS 'Templates de prompts IA versionnés avec métriques de performance';
COMMENT ON COLUMN ai_prompt_templates.variables IS 'Variables à interpoler dans le prompt (format JSON array)';
COMMENT ON COLUMN ai_prompt_templates.success_rate IS 'Taux de succès basé sur les feedbacks (0-100%)';
COMMENT ON COLUMN ai_prompt_templates.parent_template_id IS 'Template parent pour traçabilité du versioning';


-- ===============================================
-- 3. TABLE HISTORIQUE DES UPDATES MONDAY.COM
-- ===============================================
-- Description: Historique complet des commentaires Monday avec analyse
-- Priorité: MOYENNE
-- Impact: Traçabilité, analyse comportementale, amélioration détection

CREATE TABLE IF NOT EXISTS monday_updates_history (
    update_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    task_id BIGINT REFERENCES tasks(tasks_id) ON DELETE CASCADE,
    monday_update_id VARCHAR(255) UNIQUE NOT NULL,
    
    -- Auteur
    author_monday_user_id BIGINT,
    author_user_id BIGINT REFERENCES system_users(user_id) ON DELETE SET NULL,
    author_name VARCHAR(255),
    
    -- Contenu
    content TEXT NOT NULL,
    content_plain TEXT,  -- Version sans formatage HTML/Markdown
    content_length INTEGER GENERATED ALWAYS AS (LENGTH(content)) STORED,
    is_from_system BOOLEAN DEFAULT FALSE,  -- false = humain, true = bot/système
    
    -- Threading (gestion des conversations)
    parent_update_id BIGINT REFERENCES monday_updates_history(update_id),
    thread_id BIGINT,  -- Tous les updates du même thread partagent ce ID
    thread_depth INTEGER DEFAULT 0,  -- Profondeur dans le thread (0 = racine)
    
    -- Analyse IA (si disponible)
    detected_intent VARCHAR(50),  -- 'new_request', 'bug_report', 'affirmation', 'question', etc.
    confidence_score NUMERIC(3,2) CHECK (confidence_score BETWEEN 0 AND 1),
    triggered_workflow BOOLEAN DEFAULT FALSE,
    trigger_id BIGINT,  -- Référence vers task_update_triggers si workflow déclenché
    
    -- Métadonnées Monday
    monday_board_id BIGINT,
    monday_pulse_id BIGINT,
    reactions JSONB DEFAULT '[]'::jsonb,  -- Réactions (likes, etc.)
    attachments JSONB DEFAULT '[]'::jsonb,  -- Fichiers attachés
    
    -- Métadonnées supplémentaires
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_monday_updates_task ON monday_updates_history(task_id, created_at DESC);
CREATE INDEX idx_monday_updates_author ON monday_updates_history(author_user_id, created_at DESC);
CREATE INDEX idx_monday_updates_thread ON monday_updates_history(thread_id);
CREATE INDEX idx_monday_updates_parent ON monday_updates_history(parent_update_id);
CREATE INDEX idx_monday_updates_workflow ON monday_updates_history(triggered_workflow) WHERE triggered_workflow = TRUE;
CREATE INDEX idx_monday_updates_intent ON monday_updates_history(detected_intent) WHERE detected_intent IS NOT NULL;
CREATE INDEX idx_monday_updates_system ON monday_updates_history(is_from_system);

COMMENT ON TABLE monday_updates_history IS 'Historique complet des commentaires/updates Monday.com avec analyse IA';
COMMENT ON COLUMN monday_updates_history.thread_id IS 'ID du thread de conversation (tous les updates liés)';
COMMENT ON COLUMN monday_updates_history.detected_intent IS 'Type de commentaire détecté par LLM';
COMMENT ON COLUMN monday_updates_history.triggered_workflow IS 'Ce commentaire a-t-il déclenché un workflow?';


-- ===============================================
-- 4. TABLE FEEDBACK QUALITÉ DU CODE GÉNÉRÉ
-- ===============================================
-- Description: Feedback structuré sur la qualité du code IA
-- Priorité: MOYENNE-HAUTE
-- Impact: Amélioration continue, machine learning, optimisation prompts

CREATE TABLE IF NOT EXISTS code_quality_feedback (
    feedback_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    ai_code_generation_id BIGINT REFERENCES ai_code_generations(ai_code_generations_id) ON DELETE CASCADE,
    task_run_id BIGINT REFERENCES task_runs(tasks_runs_id) ON DELETE CASCADE,
    
    -- Ratings détaillés (1-5 étoiles)
    overall_rating INTEGER CHECK (overall_rating BETWEEN 1 AND 5),
    code_correctness INTEGER CHECK (code_correctness BETWEEN 1 AND 5),
    code_style INTEGER CHECK (code_style BETWEEN 1 AND 5),
    code_efficiency INTEGER CHECK (code_efficiency BETWEEN 1 AND 5),
    code_security INTEGER CHECK (code_security BETWEEN 1 AND 5),
    code_maintainability INTEGER CHECK (code_maintainability BETWEEN 1 AND 5),
    code_testability INTEGER CHECK (code_testability BETWEEN 1 AND 5),
    
    -- Feedback détaillé
    feedback_type VARCHAR(50) NOT NULL,  -- 'human', 'automated_tests', 'linter', 'code_review', 'security_scan', 'performance_test'
    feedback_source VARCHAR(100),  -- 'manual_review', 'github_review', 'sonarqube', 'eslint', 'pytest', etc.
    comments TEXT,
    positive_aspects TEXT[],  -- Points positifs identifiés
    issues_found TEXT[],  -- ['bug', 'performance', 'security', 'style', 'logic', 'edge_case']
    suggestions TEXT,  -- Suggestions d'amélioration
    
    -- Décision
    code_accepted BOOLEAN,
    requires_rework BOOLEAN DEFAULT FALSE,
    rework_priority VARCHAR(20) CHECK (rework_priority IN ('low', 'medium', 'high', 'critical')),
    
    -- Métriques techniques (si disponibles)
    lines_of_code INTEGER,
    cyclomatic_complexity INTEGER,
    code_coverage_percent NUMERIC(5,2),
    performance_score NUMERIC(5,2),
    security_score NUMERIC(5,2),
    
    -- Contexte du review
    reviewer_user_id BIGINT REFERENCES system_users(user_id),
    reviewer_name VARCHAR(255),
    review_duration_seconds INTEGER,
    review_tool_used VARCHAR(100),
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_code_feedback_generation ON code_quality_feedback(ai_code_generation_id);
CREATE INDEX idx_code_feedback_run ON code_quality_feedback(task_run_id);
CREATE INDEX idx_code_feedback_rating ON code_quality_feedback(overall_rating DESC);
CREATE INDEX idx_code_feedback_accepted ON code_quality_feedback(code_accepted);
CREATE INDEX idx_code_feedback_type ON code_quality_feedback(feedback_type);
CREATE INDEX idx_code_feedback_reviewer ON code_quality_feedback(reviewer_user_id);
CREATE INDEX idx_code_feedback_created ON code_quality_feedback(created_at DESC);

COMMENT ON TABLE code_quality_feedback IS 'Feedback structuré sur la qualité du code généré par IA';
COMMENT ON COLUMN code_quality_feedback.feedback_type IS 'Source du feedback: humain, tests automatiques, linter, etc.';
COMMENT ON COLUMN code_quality_feedback.code_accepted IS 'Le code a-t-il été accepté en l''état?';
COMMENT ON COLUMN code_quality_feedback.requires_rework IS 'Le code nécessite-t-il des modifications?';


-- ===============================================
-- 5. TABLE MÉMOIRE CONTEXTUELLE PAR TÂCHE/PROJET
-- ===============================================
-- Description: Apprentissage contextuel et préférences par projet
-- Priorité: MOYENNE
-- Impact: Personnalisation, optimisation, réutilisation patterns

CREATE TABLE IF NOT EXISTS task_context_memory (
    context_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    task_id BIGINT REFERENCES tasks(tasks_id) ON DELETE CASCADE,
    repository_url VARCHAR(500),  -- Peut être lié au repo plutôt qu'à la tâche
    
    -- Clé-valeur flexible
    key VARCHAR(255) NOT NULL,
    value TEXT NOT NULL,
    value_type VARCHAR(50) DEFAULT 'string',  -- 'string', 'json', 'boolean', 'number', 'array'
    
    -- Catégorisation
    context_type VARCHAR(50) NOT NULL,  -- 'user_preference', 'code_pattern', 'project_convention', 'learned_behavior', 'coding_style', 'architecture_decision'
    category VARCHAR(100),  -- 'style', 'architecture', 'testing', 'naming', 'framework', 'library'
    subcategory VARCHAR(100),
    
    -- Origine & Fiabilité
    source VARCHAR(50) NOT NULL,  -- 'learned', 'manual', 'extracted', 'inferred', 'user_provided'
    confidence NUMERIC(3,2) DEFAULT 1.0 CHECK (confidence BETWEEN 0 AND 1),
    importance VARCHAR(20) DEFAULT 'medium' CHECK (importance IN ('low', 'medium', 'high', 'critical')),
    
    -- Application
    applies_to TEXT[],  -- Liste de fichiers/patterns où ce contexte s'applique
    scope VARCHAR(50) DEFAULT 'task',  -- 'task', 'repository', 'organization', 'global'
    
    -- Lifecycle
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ,
    access_count INTEGER DEFAULT 0,
    last_accessed_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT TRUE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb,
    
    CONSTRAINT unique_task_context_key UNIQUE (task_id, key)
);

CREATE INDEX idx_task_context_task ON task_context_memory(task_id, context_type);
CREATE INDEX idx_task_context_repository ON task_context_memory(repository_url) WHERE repository_url IS NOT NULL;
CREATE INDEX idx_task_context_type ON task_context_memory(context_type, category);
CREATE INDEX idx_task_context_scope ON task_context_memory(scope, is_active);
CREATE INDEX idx_task_context_expires ON task_context_memory(expires_at) WHERE expires_at IS NOT NULL;
CREATE INDEX idx_task_context_confidence ON task_context_memory(confidence DESC, importance);

COMMENT ON TABLE task_context_memory IS 'Mémoire contextuelle et apprentissage par tâche/projet/repository';
COMMENT ON COLUMN task_context_memory.scope IS 'Portée d''application: task (une tâche), repository (tout le repo), organization, global';
COMMENT ON COLUMN task_context_memory.confidence IS 'Niveau de confiance dans cette information (0-1)';
COMMENT ON COLUMN task_context_memory.applies_to IS 'Patterns de fichiers où ce contexte s''applique (ex: ["*.tsx", "components/**"])';


-- ===============================================
-- 6. TABLE USAGE DES PROMPTS (Tracking détaillé)
-- ===============================================
-- Description: Tracking de l'utilisation des prompts avec métriques
-- Priorité: MOYENNE
-- Impact: Optimisation, A/B testing, statistiques

CREATE TABLE IF NOT EXISTS ai_prompt_usage (
    usage_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    template_id BIGINT REFERENCES ai_prompt_templates(template_id) ON DELETE CASCADE,
    ai_interaction_id BIGINT REFERENCES ai_interactions(ai_interaction_id) ON DELETE CASCADE,
    task_run_id BIGINT REFERENCES task_runs(tasks_runs_id) ON DELETE CASCADE,
    
    -- Variables utilisées
    variables_provided JSONB,  -- Variables fournies lors de l'interpolation
    final_prompt TEXT,  -- Prompt final après interpolation des variables
    final_prompt_length INTEGER GENERATED ALWAYS AS (LENGTH(final_prompt)) STORED,
    
    -- Configuration LLM utilisée
    model_used VARCHAR(100),
    temperature_used NUMERIC(3,2),
    max_tokens_used INTEGER,
    
    -- Résultat
    success BOOLEAN NOT NULL,
    quality_score NUMERIC(3,2) CHECK (quality_score BETWEEN 0 AND 5),
    execution_time_ms INTEGER,
    
    -- Tokens & Coût
    input_tokens INTEGER,
    output_tokens INTEGER,
    total_tokens INTEGER GENERATED ALWAYS AS (COALESCE(input_tokens, 0) + COALESCE(output_tokens, 0)) STORED,
    cost_usd NUMERIC(10,6),
    
    -- Erreurs
    error_occurred BOOLEAN DEFAULT FALSE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    
    -- Métadonnées
    user_id BIGINT REFERENCES system_users(user_id),
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_prompt_usage_template ON ai_prompt_usage(template_id, created_at DESC);
CREATE INDEX idx_prompt_usage_interaction ON ai_prompt_usage(ai_interaction_id);
CREATE INDEX idx_prompt_usage_run ON ai_prompt_usage(task_run_id);
CREATE INDEX idx_prompt_usage_success ON ai_prompt_usage(success, quality_score DESC);
CREATE INDEX idx_prompt_usage_cost ON ai_prompt_usage(cost_usd DESC);
CREATE INDEX idx_prompt_usage_user ON ai_prompt_usage(user_id, created_at DESC);

COMMENT ON TABLE ai_prompt_usage IS 'Tracking détaillé de l''utilisation des prompts avec métriques de performance';
COMMENT ON COLUMN ai_prompt_usage.final_prompt IS 'Prompt final envoyé au LLM (après interpolation des variables)';
COMMENT ON COLUMN ai_prompt_usage.quality_score IS 'Score de qualité du résultat (0-5), peut provenir de feedback automatique ou humain';


-- ===============================================
-- 7. TABLE API KEYS (Optionnel - si API publique)
-- ===============================================
-- Description: Gestion des clés API pour accès externe
-- Priorité: BASSE (sauf si API publique prévue)
-- Impact: Sécurité, rate limiting

CREATE TABLE IF NOT EXISTS api_keys (
    api_key_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    key_hash VARCHAR(255) UNIQUE NOT NULL,  -- Hash SHA256 de la clé
    key_prefix VARCHAR(20) NOT NULL,  -- Premiers caractères pour identification (ex: "sk_live_abc...")
    
    -- Propriétaire
    owner_user_id BIGINT REFERENCES system_users(user_id) ON DELETE CASCADE,
    owner_name VARCHAR(255),
    description TEXT,
    
    -- Permissions
    permissions JSONB DEFAULT '["read"]'::jsonb,  -- ['read', 'write', 'admin', 'create_tasks', 'view_logs', etc.]
    scopes TEXT[],  -- Restrictions optionnelles ['tasks:read', 'workflows:execute', etc.]
    
    -- Rate limiting
    rate_limit_per_minute INTEGER DEFAULT 60,
    rate_limit_per_hour INTEGER DEFAULT 1000,
    rate_limit_per_day INTEGER DEFAULT 10000,
    
    -- Usage
    last_used_at TIMESTAMPTZ,
    usage_count INTEGER DEFAULT 0,
    total_requests INTEGER DEFAULT 0,
    
    -- Lifecycle
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ,
    revoked_at TIMESTAMPTZ,
    is_active BOOLEAN DEFAULT TRUE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

CREATE INDEX idx_api_keys_owner ON api_keys(owner_user_id);
CREATE INDEX idx_api_keys_active ON api_keys(is_active) WHERE is_active = TRUE;
CREATE INDEX idx_api_keys_expires ON api_keys(expires_at) WHERE expires_at IS NOT NULL;

COMMENT ON TABLE api_keys IS 'Clés API pour accès externe au système (si API publique)';
COMMENT ON COLUMN api_keys.key_hash IS 'Hash SHA256 de la clé API (stockage sécurisé)';
COMMENT ON COLUMN api_keys.key_prefix IS 'Préfixe de la clé pour identification sans révéler la clé complète';


-- ===============================================
-- 8. TABLE RATE LIMITS (Optionnel)
-- ===============================================
-- Description: Tracking des rate limits par entité
-- Priorité: BASSE
-- Impact: Protection contre abus, gestion quotas

CREATE TABLE IF NOT EXISTS rate_limits (
    rate_limit_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    entity_type VARCHAR(50) NOT NULL,  -- 'user', 'api_key', 'ip_address', 'organization'
    entity_id VARCHAR(255) NOT NULL,
    
    -- Ressource limitée
    resource_type VARCHAR(50) NOT NULL,  -- 'api_requests', 'ai_tokens', 'workflow_executions'
    provider VARCHAR(50),  -- 'anthropic', 'openai', 'all', etc.
    
    -- Compteurs
    requests_count INTEGER DEFAULT 0,
    tokens_used INTEGER DEFAULT 0,
    
    -- Fenêtre temporelle
    window_start TIMESTAMPTZ NOT NULL,
    window_end TIMESTAMPTZ NOT NULL,
    window_duration_seconds INTEGER NOT NULL,
    
    -- Limites
    max_requests INTEGER,
    max_tokens INTEGER,
    limit_exceeded BOOLEAN DEFAULT FALSE,
    exceeded_at TIMESTAMPTZ,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

CREATE INDEX idx_rate_limits_entity ON rate_limits(entity_type, entity_id, window_start);
CREATE INDEX idx_rate_limits_window ON rate_limits(window_end) WHERE limit_exceeded = FALSE;
CREATE INDEX idx_rate_limits_exceeded ON rate_limits(limit_exceeded) WHERE limit_exceeded = TRUE;

COMMENT ON TABLE rate_limits IS 'Tracking des rate limits par utilisateur/API key/IP';


-- ===============================================
-- 9. CORRECTION TABLE AI_USAGE_LOGS (Existante)
-- ===============================================
-- Description: Correction de la table existante (problèmes identifiés)
-- Priorité: CRITIQUE
-- Impact: Intégrité référentielle, cohérence données

-- Ajouter clé primaire si elle n'existe pas
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE table_name = 'ai_usage_logs' AND constraint_type = 'PRIMARY KEY'
    ) THEN
        ALTER TABLE ai_usage_logs 
        ADD COLUMN ai_usage_log_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY;
    END IF;
END $$;

-- Corriger le type de task_id (VARCHAR -> BIGINT)
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'ai_usage_logs' 
        AND column_name = 'task_id' 
        AND data_type = 'character varying'
    ) THEN
        -- Sauvegarder les données
        CREATE TEMP TABLE ai_usage_logs_backup AS SELECT * FROM ai_usage_logs;
        
        -- Modifier le type
        ALTER TABLE ai_usage_logs 
        ALTER COLUMN task_id TYPE BIGINT USING task_id::BIGINT;
        
        -- Ajouter foreign key
        ALTER TABLE ai_usage_logs 
        ADD CONSTRAINT fk_ai_usage_task 
        FOREIGN KEY (task_id) REFERENCES tasks(tasks_id) ON DELETE CASCADE;
    END IF;
END $$;

-- Ajouter colonnes manquantes
ALTER TABLE ai_usage_logs 
ADD COLUMN IF NOT EXISTS task_run_id BIGINT REFERENCES task_runs(tasks_runs_id) ON DELETE CASCADE;

ALTER TABLE ai_usage_logs 
ADD COLUMN IF NOT EXISTS run_step_id BIGINT REFERENCES run_steps(run_steps_id) ON DELETE SET NULL;

ALTER TABLE ai_usage_logs 
ADD COLUMN IF NOT EXISTS actual_cost NUMERIC(12, 6) CHECK (actual_cost >= 0);

ALTER TABLE ai_usage_logs 
ADD COLUMN IF NOT EXISTS duration_seconds NUMERIC(8, 3);

ALTER TABLE ai_usage_logs 
ADD COLUMN IF NOT EXISTS success BOOLEAN DEFAULT TRUE NOT NULL;

ALTER TABLE ai_usage_logs 
ADD COLUMN IF NOT EXISTS error_message TEXT;

ALTER TABLE ai_usage_logs 
ADD COLUMN IF NOT EXISTS timestamp TIMESTAMPTZ DEFAULT NOW();

-- Ajouter contrainte de cohérence des tokens
ALTER TABLE ai_usage_logs 
ADD CONSTRAINT ai_usage_logs_tokens_coherent 
CHECK (total_tokens = input_tokens + output_tokens);

-- Ajouter index performants
CREATE INDEX IF NOT EXISTS idx_ai_usage_logs_task ON ai_usage_logs(task_id, timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_ai_usage_logs_run ON ai_usage_logs(task_run_id, timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_ai_usage_logs_provider ON ai_usage_logs(provider, timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_ai_usage_logs_timestamp ON ai_usage_logs(timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_ai_usage_logs_cost ON ai_usage_logs(estimated_cost DESC);

COMMENT ON TABLE ai_usage_logs IS 'Logs d''utilisation des services IA (corrigé avec FK et PK)';


-- ===============================================
-- 10. FONCTIONS UTILITAIRES
-- ===============================================

-- Fonction: Réinitialiser quotas mensuels utilisateurs
CREATE OR REPLACE FUNCTION reset_monthly_user_quotas()
RETURNS INTEGER AS $$
DECLARE
    updated_count INTEGER;
BEGIN
    UPDATE system_users
    SET 
        tokens_used_this_month = 0,
        updated_at = NOW()
    WHERE 
        is_active = TRUE
        AND EXTRACT(DAY FROM NOW()) = monthly_reset_day;
    
    GET DIAGNOSTICS updated_count = ROW_COUNT;
    
    -- Logger l'événement
    INSERT INTO application_logs (level, source_component, action, message, metadata)
    VALUES (
        'INFO',
        'scheduled_task',
        'reset_user_quotas',
        format('Quotas réinitialisés pour %s utilisateurs', updated_count),
        jsonb_build_object('users_count', updated_count, 'reset_date', NOW())
    );
    
    RETURN updated_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION reset_monthly_user_quotas() IS 'Réinitialise les quotas de tokens mensuels des utilisateurs actifs';


-- Fonction: Mettre à jour statistiques template prompt
CREATE OR REPLACE FUNCTION update_prompt_template_stats()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE ai_prompt_templates
    SET 
        usage_count = usage_count + 1,
        success_rate = (
            SELECT AVG(CASE WHEN success THEN 100.0 ELSE 0.0 END)
            FROM ai_prompt_usage
            WHERE template_id = NEW.template_id
        ),
        avg_quality_score = (
            SELECT AVG(quality_score)
            FROM ai_prompt_usage
            WHERE template_id = NEW.template_id AND quality_score IS NOT NULL
        ),
        avg_execution_time_ms = (
            SELECT AVG(execution_time_ms)
            FROM ai_prompt_usage
            WHERE template_id = NEW.template_id AND execution_time_ms IS NOT NULL
        ),
        avg_cost_usd = (
            SELECT AVG(cost_usd)
            FROM ai_prompt_usage
            WHERE template_id = NEW.template_id AND cost_usd IS NOT NULL
        ),
        updated_at = NOW()
    WHERE template_id = NEW.template_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_prompt_stats
AFTER INSERT ON ai_prompt_usage
FOR EACH ROW
EXECUTE FUNCTION update_prompt_template_stats();

COMMENT ON FUNCTION update_prompt_template_stats() IS 'Met à jour automatiquement les stats d''un template prompt après chaque utilisation';


-- Fonction: Nettoyer contextes expirés
CREATE OR REPLACE FUNCTION cleanup_expired_contexts()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM task_context_memory
    WHERE expires_at IS NOT NULL AND expires_at < NOW();
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    -- Logger
    INSERT INTO application_logs (level, source_component, action, message, metadata)
    VALUES (
        'INFO',
        'scheduled_task',
        'cleanup_expired_contexts',
        format('%s contextes expirés supprimés', deleted_count),
        jsonb_build_object('deleted_count', deleted_count, 'cleanup_date', NOW())
    );
    
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION cleanup_expired_contexts() IS 'Supprime les contextes expirés de la mémoire contextuelle';


-- ===============================================
-- 11. VUES UTILES
-- ===============================================

-- Vue: Statistiques par utilisateur
CREATE OR REPLACE VIEW user_activity_stats AS
SELECT 
    u.user_id,
    u.email,
    u.username,
    u.role,
    u.tokens_used_this_month,
    u.monthly_token_quota,
    ROUND(100.0 * u.tokens_used_this_month / NULLIF(u.monthly_token_quota, 0), 2) as quota_usage_percent,
    COUNT(DISTINCT tr.tasks_runs_id) as runs_count,
    COUNT(DISTINCT t.tasks_id) as tasks_count,
    u.last_active_at,
    u.is_active
FROM system_users u
LEFT JOIN tasks t ON t.created_by_user_id = u.user_id
LEFT JOIN task_runs tr ON tr.task_id = t.tasks_id
WHERE u.is_active = TRUE
GROUP BY u.user_id;

COMMENT ON VIEW user_activity_stats IS 'Statistiques d''activité et d''usage des utilisateurs';


-- Vue: Performance des prompts
CREATE OR REPLACE VIEW prompt_performance_dashboard AS
SELECT 
    pt.template_id,
    pt.name,
    pt.category,
    pt.version,
    pt.is_active,
    pt.is_default,
    pt.usage_count,
    pt.success_rate,
    pt.avg_quality_score,
    pt.avg_execution_time_ms,
    pt.avg_cost_usd,
    COUNT(DISTINCT pu.usage_id) as total_usages_detailed,
    AVG(pu.execution_time_ms) as calculated_avg_time,
    SUM(pu.cost_usd) as total_cost,
    pt.created_at,
    pt.updated_at
FROM ai_prompt_templates pt
LEFT JOIN ai_prompt_usage pu ON pt.template_id = pu.template_id
GROUP BY pt.template_id;

COMMENT ON VIEW prompt_performance_dashboard IS 'Dashboard de performance des templates de prompts';


-- Vue: Qualité du code par run
CREATE OR REPLACE VIEW code_quality_by_run AS
SELECT 
    tr.tasks_runs_id,
    tr.task_id,
    tr.status as run_status,
    COUNT(DISTINCT cqf.feedback_id) as feedback_count,
    AVG(cqf.overall_rating) as avg_overall_rating,
    AVG(cqf.code_correctness) as avg_correctness,
    AVG(cqf.code_style) as avg_style,
    AVG(cqf.code_efficiency) as avg_efficiency,
    AVG(cqf.code_security) as avg_security,
    SUM(CASE WHEN cqf.code_accepted THEN 1 ELSE 0 END) as accepted_count,
    SUM(CASE WHEN cqf.requires_rework THEN 1 ELSE 0 END) as rework_count
FROM task_runs tr
LEFT JOIN code_quality_feedback cqf ON tr.tasks_runs_id = cqf.task_run_id
GROUP BY tr.tasks_runs_id;

COMMENT ON VIEW code_quality_by_run IS 'Agrégation des feedbacks qualité code par run';


-- Vue: Monday updates avec déclenchements
CREATE OR REPLACE VIEW monday_updates_with_triggers AS
SELECT 
    muh.update_id,
    muh.task_id,
    muh.monday_update_id,
    muh.author_name,
    muh.content,
    muh.detected_intent,
    muh.confidence_score,
    muh.triggered_workflow,
    muh.created_at,
    tut.trigger_id,
    tut.new_run_id,
    tut.celery_task_id
FROM monday_updates_history muh
LEFT JOIN task_update_triggers tut ON muh.monday_update_id = tut.monday_update_id::VARCHAR
ORDER BY muh.created_at DESC;

COMMENT ON VIEW monday_updates_with_triggers IS 'Updates Monday avec info de déclenchement de workflow';


-- ===============================================
-- 12. INSERTIONS D'EXEMPLES (Optionnel)
-- ===============================================

-- Exemple: Template prompt pour génération de code
INSERT INTO ai_prompt_templates (
    name, category, version, description,
    system_prompt, user_prompt_template, variables,
    model_recommended, temperature, max_tokens
) VALUES (
    'code_implementation_v2',
    'code_generation',
    '2.0',
    'Génération de code à partir d''une description de tâche',
    'Tu es un développeur expert. Tu génères du code de haute qualité, bien testé et documenté.',
    E'Implémente la fonctionnalité suivante:\n\nTâche: {task_description}\n\nRepository: {repo_url}\nLangage principal: {language}\nFramework: {framework}\n\nInstructions supplémentaires: {additional_instructions}',
    '["task_description", "repo_url", "language", "framework", "additional_instructions"]'::jsonb,
    'claude-3-5-sonnet-20241022',
    0.7,
    8000
) ON CONFLICT (name, version) DO NOTHING;

-- Exemple: Template pour détection d'intention dans updates
INSERT INTO ai_prompt_templates (
    name, category, version, description,
    system_prompt, user_prompt_template, variables,
    model_recommended, temperature, max_tokens
) VALUES (
    'update_intent_detection_v1',
    'update_detection',
    '1.0',
    'Détection de l''intention dans les commentaires Monday.com',
    'Tu analyses les commentaires pour déterminer s''ils nécessitent une action.',
    E'Analyse ce commentaire Monday.com:\n\nCommentaire: {update_text}\n\nContexte de la tâche:\n- Titre: {task_title}\n- Statut: {task_status}\n- Description: {task_description}\n\nDétermine le type de commentaire et si un workflow doit être déclenché.',
    '["update_text", "task_title", "task_status", "task_description"]'::jsonb,
    'claude-3-5-sonnet-20241022',
    0.3,
    1000
) ON CONFLICT (name, version) DO NOTHING;

COMMIT;

-- ===============================================
-- FIN DE LA MIGRATION
-- ===============================================

-- Pour appliquer cette migration:
-- psql -U votre_user -d votre_database -f migration_conversational_features.sql

-- Pour vérifier:
-- SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' ORDER BY table_name;

-- Pour rollback (à créer séparément si nécessaire):
-- BEGIN;
-- DROP VIEW IF EXISTS monday_updates_with_triggers CASCADE;
-- DROP VIEW IF EXISTS code_quality_by_run CASCADE;
-- DROP VIEW IF EXISTS prompt_performance_dashboard CASCADE;
-- DROP VIEW IF EXISTS user_activity_stats CASCADE;
-- DROP FUNCTION IF EXISTS cleanup_expired_contexts() CASCADE;
-- DROP FUNCTION IF EXISTS update_prompt_template_stats() CASCADE;
-- DROP FUNCTION IF EXISTS reset_monthly_user_quotas() CASCADE;
-- DROP TABLE IF EXISTS rate_limits CASCADE;
-- DROP TABLE IF EXISTS api_keys CASCADE;
-- DROP TABLE IF EXISTS ai_prompt_usage CASCADE;
-- DROP TABLE IF EXISTS task_context_memory CASCADE;
-- DROP TABLE IF EXISTS code_quality_feedback CASCADE;
-- DROP TABLE IF EXISTS monday_updates_history CASCADE;
-- DROP TABLE IF EXISTS ai_prompt_templates CASCADE;
-- DROP TABLE IF EXISTS system_users CASCADE;
-- COMMIT;
