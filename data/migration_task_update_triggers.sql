-- Migration: Ajout du système de déclenchement de workflow depuis des updates Monday
-- Date: 11 octobre 2025
-- Objectif: Permettre le déclenchement automatique de nouveaux workflows quand 
--          un commentaire de demande arrive sur une tâche terminée

-- ============================================================================
-- ÉTAPE 1: Créer la table task_update_triggers
-- ============================================================================

-- Table pour tracker les déclenchements de workflow depuis des updates
CREATE TABLE IF NOT EXISTS task_update_triggers (
    trigger_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    task_id BIGINT REFERENCES tasks(tasks_id) ON DELETE CASCADE,
    monday_update_id VARCHAR(255) NOT NULL,
    webhook_id BIGINT,  -- Référence optionnelle sans contrainte FK (webhook_events a une clé composite)
    update_text TEXT NOT NULL,
    
    -- Analyse LLM
    detected_type VARCHAR(50) NOT NULL,  -- UpdateType enum
    confidence FLOAT NOT NULL,
    requires_workflow BOOLEAN NOT NULL DEFAULT FALSE,
    analysis_reasoning TEXT,
    extracted_requirements JSONB,
    
    -- Workflow déclenché
    triggered_workflow BOOLEAN DEFAULT FALSE,
    new_run_id BIGINT REFERENCES task_runs(tasks_runs_id) ON DELETE SET NULL,
    celery_task_id VARCHAR(255),
    
    -- Métadonnées
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMPTZ,
    
    CONSTRAINT unique_monday_update UNIQUE (monday_update_id)
);

-- Index pour les requêtes fréquentes
CREATE INDEX IF NOT EXISTS idx_update_triggers_task_id 
    ON task_update_triggers(task_id);

CREATE INDEX IF NOT EXISTS idx_update_triggers_workflow 
    ON task_update_triggers(triggered_workflow) 
    WHERE triggered_workflow = TRUE;

CREATE INDEX IF NOT EXISTS idx_update_triggers_created_at 
    ON task_update_triggers(created_at DESC);

CREATE INDEX IF NOT EXISTS idx_update_triggers_type 
    ON task_update_triggers(detected_type);

-- Commentaires pour documentation
COMMENT ON TABLE task_update_triggers IS 
    'Suivi des déclenchements de workflow depuis des updates Monday.com';

COMMENT ON COLUMN task_update_triggers.trigger_id IS 
    'ID unique du trigger';

COMMENT ON COLUMN task_update_triggers.task_id IS 
    'Référence à la tâche originale';

COMMENT ON COLUMN task_update_triggers.monday_update_id IS 
    'ID de l''update Monday.com qui a déclenché l''analyse';

COMMENT ON COLUMN task_update_triggers.detected_type IS 
    'Type d''update détecté par le LLM (new_request, modification, bug_report, etc.)';

COMMENT ON COLUMN task_update_triggers.confidence IS 
    'Niveau de confiance du LLM dans sa détection (0.0-1.0)';

COMMENT ON COLUMN task_update_triggers.requires_workflow IS 
    'Indique si l''update nécessite le déclenchement d''un workflow';

COMMENT ON COLUMN task_update_triggers.extracted_requirements IS 
    'Requirements extraits par le LLM (titre, description, priorité, etc.)';

COMMENT ON COLUMN task_update_triggers.triggered_workflow IS 
    'Indique si un workflow a effectivement été déclenché';

COMMENT ON COLUMN task_update_triggers.new_run_id IS 
    'Référence au nouveau task_run créé si un workflow a été déclenché';


-- ============================================================================
-- ÉTAPE 2: Modifier la table task_runs pour tracker l'origine
-- ============================================================================

-- Ajouter une colonne pour lier un run à un update Monday
ALTER TABLE task_runs 
ADD COLUMN IF NOT EXISTS triggered_by_update_id VARCHAR(255);

-- Index pour rechercher les runs déclenchés par des updates
CREATE INDEX IF NOT EXISTS idx_task_runs_update_trigger 
    ON task_runs(triggered_by_update_id) 
    WHERE triggered_by_update_id IS NOT NULL;

COMMENT ON COLUMN task_runs.triggered_by_update_id IS 
    'ID de l''update Monday.com qui a déclenché ce run (pour les workflows lancés depuis des commentaires)';


-- ============================================================================
-- ÉTAPE 3: Vues utiles pour le monitoring
-- ============================================================================

-- Vue pour les déclenchements récents
CREATE OR REPLACE VIEW v_recent_update_triggers AS
SELECT 
    t.trigger_id,
    t.task_id,
    tasks.title AS task_title,
    tasks.monday_item_id,
    t.monday_update_id,
    t.detected_type,
    t.confidence,
    t.requires_workflow,
    t.triggered_workflow,
    t.new_run_id,
    t.created_at,
    SUBSTRING(t.update_text FROM 1 FOR 100) AS update_preview,
    t.extracted_requirements->>'title' AS request_title,
    t.extracted_requirements->>'priority' AS request_priority
FROM task_update_triggers t
LEFT JOIN tasks ON t.task_id = tasks.tasks_id
ORDER BY t.created_at DESC
LIMIT 50;

COMMENT ON VIEW v_recent_update_triggers IS 
    'Vue des 50 déclenchements les plus récents avec informations essentielles';


-- Vue pour les statistiques par type d'update
CREATE OR REPLACE VIEW v_update_trigger_stats AS
SELECT 
    detected_type,
    COUNT(*) AS total_count,
    SUM(CASE WHEN requires_workflow THEN 1 ELSE 0 END) AS requires_workflow_count,
    SUM(CASE WHEN triggered_workflow THEN 1 ELSE 0 END) AS triggered_workflow_count,
    AVG(confidence) AS avg_confidence,
    MIN(created_at) AS first_seen,
    MAX(created_at) AS last_seen
FROM task_update_triggers
GROUP BY detected_type
ORDER BY total_count DESC;

COMMENT ON VIEW v_update_trigger_stats IS 
    'Statistiques agrégées par type d''update détecté';


-- ============================================================================
-- ÉTAPE 4: Fonction utile pour nettoyer les anciens triggers
-- ============================================================================

CREATE OR REPLACE FUNCTION cleanup_old_update_triggers(days_to_keep INTEGER DEFAULT 90)
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    -- Supprimer les triggers plus anciens que X jours qui n'ont PAS déclenché de workflow
    DELETE FROM task_update_triggers
    WHERE created_at < NOW() - INTERVAL '1 day' * days_to_keep
      AND triggered_workflow = FALSE;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION cleanup_old_update_triggers IS 
    'Nettoie les anciens triggers qui n''ont pas déclenché de workflow (garde ceux qui ont déclenché un workflow)';


-- ============================================================================
-- ÉTAPE 5: Permissions (adapter selon votre configuration)
-- ============================================================================

-- Donner les permissions nécessaires au rôle de l'application
-- Note: Adapter le nom du rôle selon votre configuration
-- GRANT SELECT, INSERT, UPDATE, DELETE ON task_update_triggers TO your_app_role;
-- GRANT USAGE, SELECT ON SEQUENCE task_update_triggers_trigger_id_seq TO your_app_role;
-- GRANT SELECT ON v_recent_update_triggers TO your_app_role;
-- GRANT SELECT ON v_update_trigger_stats TO your_app_role;


-- ============================================================================
-- ÉTAPE 6: Données de test (optionnel)
-- ============================================================================

-- Exemple d'insertion pour tester
/*
INSERT INTO task_update_triggers (
    task_id,
    monday_update_id,
    update_text,
    detected_type,
    confidence,
    requires_workflow,
    analysis_reasoning,
    extracted_requirements,
    triggered_workflow
) VALUES (
    1,  -- Remplacer par un task_id existant
    'test_update_123',
    'Bonjour, pouvez-vous ajouter un bouton d''export en CSV ?',
    'new_request',
    0.92,
    TRUE,
    'L''utilisateur demande une nouvelle fonctionnalité d''export',
    '{"title": "Ajouter export CSV", "description": "Bouton d''export en CSV", "priority": "medium", "task_type": "feature"}'::jsonb,
    FALSE
);
*/


-- ============================================================================
-- VÉRIFICATIONS POST-MIGRATION
-- ============================================================================

-- Vérifier que la table a été créée
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.tables 
        WHERE table_name = 'task_update_triggers'
    ) THEN
        RAISE NOTICE '✅ Table task_update_triggers créée avec succès';
    ELSE
        RAISE EXCEPTION '❌ Échec création table task_update_triggers';
    END IF;
END $$;

-- Vérifier que la colonne a été ajoutée à task_runs
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'task_runs' 
        AND column_name = 'triggered_by_update_id'
    ) THEN
        RAISE NOTICE '✅ Colonne triggered_by_update_id ajoutée à task_runs';
    ELSE
        RAISE EXCEPTION '❌ Échec ajout colonne triggered_by_update_id';
    END IF;
END $$;

-- Afficher un résumé
SELECT 
    '✅ Migration task_update_triggers terminée avec succès' AS status,
    NOW() AS executed_at;

-- Afficher les statistiques initiales
SELECT 
    'task_update_triggers' AS table_name,
    COUNT(*) AS row_count
FROM task_update_triggers;

