"""N≈ìud de mise √† jour Monday - met √† jour le ticket avec les r√©sultats."""

from datetime import datetime
from models.schemas import WorkflowStatus
from models.state import GraphState
from tools.monday_tool import MondayTool
from services.github_pr_service import github_pr_service
from utils.logger import get_logger
# from utils.helpers import ensure_state_structure, add_ai_message, add_error_log  # Non utilis√©

logger = get_logger(__name__)


async def update_monday(state: GraphState) -> GraphState:
    """
    N≈ìud de mise √† jour Monday.com : met √† jour l'item avec les r√©sultats finaux.

    Ce n≈ìud :
    1. Collecte tous les r√©sultats du workflow
    2. G√©n√®re un commentaire de completion
    3. Met √† jour le statut de l'item Monday.com
    4. Attache les liens vers la PR et les artefacts
    5. Marque la t√¢che comme termin√©e

    Args:
        state: √âtat actuel du graphe

    Returns:
        √âtat mis √† jour avec le statut final
    """
    logger.info(f"üìù Mise √† jour Monday.com pour: {state['task'].title}")

    # ‚úÖ CORRECTION CRITIQUE: Assurer l'int√©grit√© de l'√©tat d√®s le d√©but
    from utils.error_handling import ensure_state_integrity
    ensure_state_integrity(state)

    # Initialiser structures si n√©cessaire
    if "results" not in state:
        state["results"] = {}

    if "ai_messages" not in state["results"]:
        state["results"]["ai_messages"] = []

    state["results"]["ai_messages"].append("üìã D√©but de la mise √† jour du ticket Monday.com...")

    try:
        # Initialiser l'outil Monday
        monday_tool = MondayTool()

        # ‚úÖ CORRECTION: V√©rifier la configuration Monday.com avant toute op√©ration
        if not hasattr(monday_tool, 'api_token') or not monday_tool.api_token:
            logger.info("üí° Monday.com non configur√© - mise √† jour ignor√©e")
            # Marquer le workflow comme compl√©t√© m√™me sans Monday.com
            state["status"] = "completed"
            if "results" not in state:
                state["results"] = {}
            state["results"]["monday_update_skipped"] = "Configuration Monday.com manquante"
            return state

        task = state["task"]

        # 1. D√©terminer le statut final
        final_status, success_level = _determine_final_status(state)

        # ‚úÖ VALIDATION CRITIQUE: V√©rifier coh√©rence merge_successful vs final_status
        if state["results"].get("merge_successful", False) and final_status != "Done":
            logger.error(f"‚ùå INCOH√âRENCE: merge_successful=True mais final_status='{final_status}'")
            logger.warning("üîß Correction automatique - For√ßage √† 'Done'")
            final_status = "Done"
            success_level = "success"
            state["results"]["status_corrected"] = True

        # 2. G√©n√©rer le commentaire de completion
        completion_comment = await _generate_completion_comment(state, success_level)

        # ‚úÖ ENRICHISSEMENT: Ajouter info de merge dans le commentaire si disponible
        if state["results"].get("merge_successful", False):
            merge_info = "\n\n‚úÖ **Pull Request merg√©e avec succ√®s**\n"
            if state["results"].get("merge_commit"):
                merge_info += f"- **Commit de merge**: `{state['results']['merge_commit']}`\n"
            if state["results"].get("merge_commit_url"):
                merge_info += f"- **Lien**: {state['results']['merge_commit_url']}\n"
            completion_comment += merge_info

        # 3. R√©cup√©rer l'URL de la PR si disponible dans les r√©sultats
        pr_url = None
        if state["results"] and "pr_info" in state["results"]:
            pr_info = state["results"]["pr_info"]
            pr_url = pr_info.get("pr_url") if isinstance(pr_info, dict) else getattr(pr_info, "pr_url", None)

        logger.info(f"üìù Mise √† jour statut: {final_status}, PR: {pr_url or 'N/A'}")

        # ‚úÖ CORRECTION: Utiliser monday_item_id pour les appels Monday.com API
        monday_item_id = str(task.monday_item_id) if task.monday_item_id else task.task_id

        # 4. Ex√©cuter la mise √† jour compl√®te
        # ‚úÖ AM√âLIORATION: Toujours mettre √† jour le statut explicitement au lieu d'utiliser complete_task
        # Mettre √† jour le statut avec le statut d√©termin√©
        status_result = await monday_tool._arun(
            action="update_item_status",
            item_id=monday_item_id,
            status=final_status
        )

        # Ajouter le commentaire
        comment_result = await monday_tool._arun(
            action="add_comment",
            item_id=monday_item_id,
            comment=completion_comment
        )

        # Si c'est un succ√®s avec une PR, ajouter le lien PR
        if success_level == "success" and pr_url:
            try:
                # ‚úÖ CORRECTION: Utiliser l'ID de colonne configur√© au lieu de "lien_pr" cod√© en dur
                from config.settings import get_settings
                settings = get_settings()
                
                if settings.monday_repository_url_column_id:
                    await monday_tool._arun(
                        action="update_column_value",
                        item_id=monday_item_id,
                        column_id=settings.monday_repository_url_column_id,
                        value=pr_url
                    )
                    logger.info(f"‚úÖ Lien PR ajout√© dans colonne {settings.monday_repository_url_column_id}: {pr_url}")
                else:
                    logger.warning("‚ö†Ô∏è Colonne Repository URL non configur√©e - lien PR non ajout√©")
            except Exception as e:
                logger.debug(f"Impossible d'ajouter le lien PR (colonne peut-√™tre absente): {e}")

        # ‚úÖ NOUVEAU: Mettre √† jour la colonne Repository URL avec la derni√®re PR fusionn√©e
        await _update_repository_url_column(state, monday_tool, monday_item_id)

        # ‚úÖ PROTECTION: S'assurer que les r√©sultats sont des dictionnaires
        if not isinstance(status_result, dict):
            logger.error(f"‚ùå status_result n'est pas un dictionnaire: {type(status_result)} - {status_result}")
            if isinstance(status_result, list):
                status_result = {"success": False, "error": f"API retourn√© liste: {status_result}"}
            else:
                status_result = {"success": False, "error": f"Type invalide: {type(status_result)}"}

        if not isinstance(comment_result, dict):
            logger.error(f"‚ùå comment_result n'est pas un dictionnaire: {type(comment_result)} - {comment_result}")
            if isinstance(comment_result, list):
                comment_result = {"success": False, "error": f"API retourn√© liste: {comment_result}"}
            else:
                comment_result = {"success": False, "error": f"Type invalide: {type(comment_result)}"}

        update_result = {
            "success": status_result.get("success", False) and comment_result.get("success", False),
            "operations": [("status", status_result), ("comment", comment_result)]
        }

        # 5. Traiter le r√©sultat de la mise √† jour
        if update_result.get("success", False):
            logger.info("‚úÖ Monday.com mis √† jour avec succ√®s")

            # ‚úÖ V√âRIFICATION POST-UPDATE: Confirmer que le statut "Done" a bien √©t√© appliqu√© apr√®s merge
            if state["results"].get("merge_successful", False):
                if final_status != "Done":
                    logger.error(f"‚ùå ERREUR: Merge r√©ussi mais statut='{final_status}'")
                    state["results"]["ai_messages"].append(
                        f"‚ö†Ô∏è Avertissement: Statut Monday='{final_status}' (attendu 'Done')"
                    )
                else:
                    logger.info("‚úÖ V√©rification: Statut 'Done' correctement appliqu√©")
                    state["results"]["ai_messages"].append(
                        "‚úÖ Statut Monday.com mis √† jour : Done"
                    )

            # ‚úÖ AJOUT: Messages informatifs pour l'affichage du workflow
            update_summary = f"‚úÖ Mise √† jour Monday.com r√©ussie - Statut: {final_status}"
            if pr_url:
                update_summary += f" | PR: {pr_url}"

            state["results"]["ai_messages"].append(update_summary)
            state["results"]["ai_messages"].append("üìã Ticket Monday.com mis √† jour avec les r√©sultats du workflow")

            # Mettre √† jour l'√©tat final
            state["status"] = WorkflowStatus.COMPLETED
            state["completed_at"] = datetime.now()

            # Stocker les r√©sultats de la mise √† jour dans results
            state["results"]["monday_update"] = {
                "success": True,
                "message": "Monday.com mis √† jour avec succ√®s",
                "final_status": final_status,
                "pr_url": pr_url,
                "comment_added": True
            }
        else:
            error_msg = update_result.get("error", "Erreur inconnue lors de la mise √† jour Monday")
            logger.error(f"‚ùå √âchec mise √† jour Monday.com: {error_msg}")

            # ‚úÖ AJOUT: Messages d'erreur pour l'affichage du workflow
            state["results"]["ai_messages"].append(f"‚ùå √âchec mise √† jour Monday.com: {error_msg}")
            state["results"]["ai_messages"].append("‚ö†Ô∏è Le workflow a √©t√© compl√©t√© mais la mise √† jour du ticket a √©chou√©")

            state["status"] = WorkflowStatus.FAILED
            state["error"] = f"√âchec mise √† jour Monday: {error_msg}"

            # Stocker les r√©sultats d'erreur dans results
            state["results"]["monday_update"] = {
                "success": False,
                "error": error_msg,
                "final_status": "√âchec mise √† jour",
                "comment_added": False
            }

    except Exception as e:
        error_msg = f"Exception lors de la mise √† jour Monday: {str(e)}"
        logger.error(error_msg, exc_info=True)

        # ‚úÖ AJOUT: Messages d'exception pour l'affichage du workflow
        state["results"]["ai_messages"].append(f"‚ùå Exception lors de la mise √† jour Monday.com: {str(e)}")
        state["results"]["ai_messages"].append("‚ö†Ô∏è Erreur technique lors de la mise √† jour du ticket")

        state["status"] = WorkflowStatus.FAILED
        state["error"] = error_msg

        # Stocker les r√©sultats d'exception dans results
        state["results"]["monday_update"] = {
            "success": False,
            "error": error_msg,
            "final_status": "Erreur technique",
            "comment_added": False
        }

    # ‚úÖ CORRECTION: Retourner l'√©tat complet au lieu d'un dictionnaire
    return state


def _determine_final_status(state: GraphState) -> tuple[str, str]:
    """
    D√©termine le statut final de la t√¢che bas√© sur les r√©sultats.

    Returns:
        Tuple (statut_monday, niveau_succ√®s)
    """
    # ‚úÖ PRIORIT√â ABSOLUE: V√©rifier merge_successful EN PREMIER (avant toute autre v√©rification)
    if state["results"] and state["results"].get("merge_successful", False):
        logger.info("üéâ Merge r√©ussi d√©tect√© - Statut forc√© √† 'Done'")
        return "Done", "success"

    # ‚úÖ NOUVEAU: V√©rifier d'abord si un statut explicite a √©t√© d√©fini (ex: apr√®s merge)
    if state["results"] and "monday_final_status" in state["results"]:
        explicit_status = state["results"]["monday_final_status"]
        logger.info(f"üìå Utilisation du statut explicite: {explicit_status}")

        # D√©terminer le niveau de succ√®s bas√© sur le statut
        if explicit_status == "Done":
            return "Done", "success"
        elif explicit_status == "Working on it":
            return "Working on it", "partial"
        elif explicit_status == "Stuck":
            return "Stuck", "failed"
        else:
            return explicit_status, "partial"

    # V√©rifier le statut du workflow avec protection
    current_status = getattr(state, 'status', WorkflowStatus.PENDING)

    if current_status == WorkflowStatus.COMPLETED:
        # V√©rifier si on a une PR
        if state["results"] and "pr_info" in state["results"]:
            return "Working on it", "partial"  # PR cr√©√©e mais pas encore merg√©e
        else:
            return "Working on it", "partial"
    elif current_status == WorkflowStatus.FAILED:
        # Analyser les erreurs pour d√©terminer le type d'√©chec
        if state["error"] and any(keyword in state["error"].lower() for keyword in ["git", "clone", "repository"]):
            return "Stuck", "failed"
        elif state["error"] and any(keyword in state["error"].lower() for keyword in ["test", "tests"]):
            return "Stuck", "failed"
        else:
            return "Stuck", "failed"
    else:
        # Workflow en cours ou annul√©
        return "Working on it", "partial"


async def _generate_completion_comment(state: GraphState, success_level: str) -> str:
    """
    G√©n√®re le commentaire de completion pour Monday.com.
    """
    task = state["task"]

    # En-t√™te bas√© sur le niveau de succ√®s
    if success_level == "success":
        header = "‚úÖ **T√¢che Compl√©t√©e avec Succ√®s**\n\n"
    elif success_level == "partial":
        header = "‚ö†Ô∏è **T√¢che Partiellement Compl√©t√©e**\n\n"
    else:
        header = "‚ùå **T√¢che √âchou√©e**\n\n"

    # Informations de base
    basic_info = f"**T√¢che**: {task.title}\n"
    basic_info += f"**Type**: {task.task_type}\n"
    basic_info += f"**Priorit√©**: {task.priority}\n\n"

    # R√©sultats d√©taill√©s
    results_section = "## üìä R√©sultats\n\n"

    # Informations sur le workflow
    if state["completed_at"] and state["started_at"]:
        duration = (state["completed_at"] - state["started_at"]).total_seconds()
        results_section += f"- **Dur√©e**: {duration:.1f} secondes\n"

    # Statut final
    final_status = getattr(state, 'status', 'Inconnu')
    results_section += f"- **Statut Final**: {final_status}\n"

    # N≈ìuds compl√©t√©s
    if state["completed_nodes"]:
        results_section += f"- **√âtapes Compl√©t√©es**: {', '.join(state["completed_nodes"])}\n"

    # Informations sur la PR
    pr_section = ""
    if state["results"] and "pr_info" in state["results"]:
        pr_info = state["results"]["pr_info"]
        pr_section = "\n## üîó Pull Request\n\n"
        if isinstance(pr_info, dict):
            pr_section += f"- **URL**: {pr_info.get('pr_url', 'N/A')}\n"
            pr_section += f"- **Branche**: {pr_info.get('branch', 'N/A')}\n"

        # ‚úÖ NOUVEAU: Ajouter les informations de merge si disponibles
        if state["results"].get("merge_successful", False):
            pr_section += "- **Statut**: ‚úÖ Merg√©e avec succ√®s\n"
            if state["results"].get("merge_commit"):
                pr_section += f"- **Commit de merge**: {state['results']['merge_commit']}\n"
            if state["results"].get("merge_commit_url"):
                pr_section += f"- **URL du commit**: {state['results']['merge_commit_url']}\n"
        elif "merge_successful" in state["results"]:
            pr_section += "- **Statut**: ‚è≥ En attente de validation/merge\n"

    # Section d'erreur si applicable
    error_section = ""
    if state["error"]:
        error_section = f"\n## ‚ùå Erreurs\n\n```\n{state["error"]}\n```\n"

    # M√©triques additionnelles
    metrics_section = "\n## üìà M√©triques\n\n"
    if state["results"]:
        for key, value in state["results"].items():
            if key not in ["pr_info"] and isinstance(value, (str, int, float)):
                metrics_section += f"- **{key.replace('_', ' ').title()}**: {value}\n"

    # Assemblage final
    comment = header + basic_info + results_section + pr_section + error_section + metrics_section

    # Footer avec timestamp
    comment += f"\n---\n*Mis √† jour automatiquement par AI-Agent le {datetime.now().strftime('%d/%m/%Y √† %H:%M')}*"

    return comment


async def _update_repository_url_column(state: GraphState, monday_tool: MondayTool, monday_item_id: str) -> None:
    """
    Met √† jour la colonne Repository URL avec l'URL de la derni√®re PR fusionn√©e.

    Cette fonction :
    1. R√©cup√®re l'URL du repository depuis l'√©tat
    2. R√©cup√®re la derni√®re PR fusionn√©e sur ce repository
    3. Met √† jour la colonne Repository URL dans Monday.com
    4. Sauvegarde l'URL en base de donn√©es

    Args:
        state: √âtat du workflow
        monday_tool: Instance de l'outil Monday
        monday_item_id: ID de l'item Monday.com
    """
    try:
        # V√©rifier si la colonne Repository URL est configur√©e
        from config.settings import get_settings
        settings = get_settings()

        if not settings.monday_repository_url_column_id:
            logger.debug("‚è≠Ô∏è Colonne Repository URL non configur√©e - mise √† jour ignor√©e")
            return

        # R√©cup√©rer l'URL du repository depuis l'√©tat
        repo_url = None
        if hasattr(state["task"], 'repository_url') and state["task"].repository_url:
            repo_url = state["task"].repository_url
        elif state["results"] and "repository_url" in state["results"]:
            repo_url = state["results"]["repository_url"]

        if not repo_url:
            logger.debug("‚è≠Ô∏è Aucune URL de repository trouv√©e - mise √† jour Repository URL ignor√©e")
            return
        
        # ‚úÖ CORRECTION: Nettoyer l'URL du repository si elle provient de Monday.com
        if isinstance(repo_url, str):
            import re
            # Format Monday.com: "GitHub - user/repo - https://github.com/user/repo"
            https_match = re.search(r'(https://github\.com/[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+(?:\.git)?)', repo_url)
            if https_match:
                cleaned_url = https_match.group(1)
                if cleaned_url.endswith('.git'):
                    cleaned_url = cleaned_url[:-4]
                if cleaned_url != repo_url:
                    logger.info(f"üßπ URL repository nettoy√©e pour update: '{repo_url[:50]}...' ‚Üí '{cleaned_url}'")
                    repo_url = cleaned_url

        logger.info(f"üîÑ Mise √† jour de la colonne Repository URL pour {repo_url}")

        # R√©cup√©rer la derni√®re PR fusionn√©e
        last_pr_result = await github_pr_service.get_last_merged_pr(repo_url)

        if last_pr_result and last_pr_result.get("success"):
            # Construire l'URL √† mettre √† jour (URL de la derni√®re PR fusionn√©e)
            pr_url = last_pr_result.get("pr_url")
            pr_number = last_pr_result.get("pr_number")
            pr_title = last_pr_result.get("pr_title", "")
            merged_at = last_pr_result.get("merged_at", "")

            # ‚úÖ SIMPLIFICATION: Le champ "text" est optionnel
            # Monday.com affichera automatiquement l'URL si "text" n'est pas fourni
            # On envoie simplement l'URL, monday_tool.py se chargera du formatage
            repository_url_value = pr_url  # Sera format√© en {"url": "..."} par monday_tool

            logger.info(f"üìå Derni√®re PR fusionn√©e: #{pr_number} - {pr_title}")
            logger.info(f"üîó URL √† mettre √† jour: {pr_url}")

            # Mettre √† jour la colonne Repository URL
            update_result = await monday_tool._arun(
                action="update_column_value",
                item_id=monday_item_id,
                column_id=settings.monday_repository_url_column_id,
                value=repository_url_value
            )

            # ‚úÖ VALIDATION ROBUSTE: V√©rifier le r√©sultat de mise √† jour Monday.com
            if update_result and update_result.get("success"):
                logger.info("‚úÖ Colonne Repository URL mise √† jour avec succ√®s")

                # ‚úÖ NOUVEAU: Sauvegarder l'URL en base de donn√©es
                save_success = await _save_last_merged_pr_to_database(state, pr_url)
                if not save_success:
                    logger.warning("‚ö†Ô∏è √âchec sauvegarde last_merged_pr_url en base (non-bloquant)")

                # Ajouter un message dans les r√©sultats
                if "ai_messages" in state["results"]:
                    state["results"]["ai_messages"].append(
                        f"‚úÖ Repository URL mis √† jour: PR #{pr_number} fusionn√©e"
                    )

                # Stocker l'info dans les r√©sultats
                state["results"]["repository_url_updated"] = {
                    "success": True,
                    "pr_url": pr_url,
                    "pr_number": pr_number,
                    "merged_at": merged_at
                }
            else:
                # ‚úÖ AM√âLIORATION: Gestion d'erreur plus robuste avec d√©tails
                error_details = {}
                if update_result:
                    error_details = {
                        "error": update_result.get("error", "Erreur inconnue"),
                        "column_id": settings.monday_repository_url_column_id,
                        "item_id": monday_item_id,
                        "attempted_value": pr_url
                    }
                    error_msg = update_result.get("error", "Erreur inconnue")
                else:
                    error_msg = "R√©sultat vide de l'API Monday.com"
                    error_details = {"error": "API returned None result"}

                logger.warning(f"‚ö†Ô∏è √âchec mise √† jour Repository URL: {error_msg}")
                logger.debug(f"üîç D√©tails erreur Repository URL: {error_details}")

                if "ai_messages" in state["results"]:
                    state["results"]["ai_messages"].append(
                        f"‚ö†Ô∏è √âchec mise √† jour Repository URL: {error_msg}"
                    )

                # ‚úÖ NOUVEAU: Stocker les erreurs pour debug
                state["results"]["repository_url_error"] = {
                    "success": False,
                    "error": error_msg,
                    "details": error_details,
                    "attempted_url": pr_url
                }
        else:
            # Aucune PR fusionn√©e trouv√©e, mettre √† jour avec l'URL du repo de base
            logger.info(f"üìù Aucune PR fusionn√©e trouv√©e, mise √† jour avec l'URL du repository: {repo_url}")

            # ‚úÖ SIMPLIFICATION: Envoyer directement l'URL
            # monday_tool.py se chargera de formater en {"url": "..."}
            update_result = await monday_tool._arun(
                action="update_column_value",
                item_id=monday_item_id,
                column_id=settings.monday_repository_url_column_id,
                value=repo_url  # Sera format√© automatiquement
            )

            if update_result and update_result.get("success"):
                logger.info("‚úÖ Colonne Repository URL mise √† jour avec l'URL du repository")

                if "ai_messages" in state["results"]:
                    state["results"]["ai_messages"].append(
                        f"üìù Repository URL mis √† jour: {repo_url}"
                    )

                state["results"]["repository_url_updated"] = {
                    "success": True,
                    "url": repo_url,
                    "type": "repository_base_url"
                }
            else:
                error_msg = update_result.get("error", "Erreur inconnue") if update_result else "R√©sultat vide"
                logger.warning(f"‚ö†Ô∏è √âchec mise √† jour Repository URL: {error_msg}")

    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Erreur lors de la mise √† jour de Repository URL: {e}")
        # Ne pas bloquer le workflow en cas d'erreur
        if "ai_messages" in state.get("results", {}):
            state["results"]["ai_messages"].append(
                f"‚ö†Ô∏è Erreur mise √† jour Repository URL: {str(e)}"
            )


async def _save_last_merged_pr_to_database(state: GraphState, last_merged_pr_url: str) -> bool:
    """
    Sauvegarde l'URL de la derni√®re PR fusionn√©e en base de donn√©es.

    Args:
        state: √âtat du workflow contenant le db_run_id
        last_merged_pr_url: URL de la derni√®re PR fusionn√©e

    Returns:
        True si sauvegarde r√©ussie, False sinon
    """
    try:
        # R√©cup√©rer le db_run_id depuis l'√©tat
        db_run_id = state.get("db_run_id") or state.get("run_id")

        if not db_run_id:
            logger.warning("‚ö†Ô∏è Aucun db_run_id trouv√© - impossible de sauvegarder last_merged_pr_url en base")
            return False

        # Utiliser le service de persistence
        from services.database_persistence_service import db_persistence

        if not db_persistence.pool:
            logger.warning("‚ö†Ô∏è Pool de connexion non initialis√© - impossible de sauvegarder last_merged_pr_url")
            return False

        # Sauvegarder l'URL en base
        success = await db_persistence.update_last_merged_pr_url(db_run_id, last_merged_pr_url)

        if success:
            logger.info(f"üíæ URL derni√®re PR fusionn√©e sauvegard√©e en base: {last_merged_pr_url}")

            # Ajouter un message dans les r√©sultats
            if "ai_messages" in state.get("results", {}):
                state["results"]["ai_messages"].append(
                    "üíæ Derni√®re PR fusionn√©e sauvegard√©e en base de donn√©es"
                )

            return True
        else:
            logger.warning("‚ö†Ô∏è √âchec de la sauvegarde de last_merged_pr_url en base")
            return False

    except Exception as e:
        logger.error(f"‚ùå Erreur lors de la sauvegarde de last_merged_pr_url: {e}")
        return False
