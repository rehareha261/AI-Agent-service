#!/usr/bin/env python3
"""
Script de test pour v√©rifier les corrections apport√©es au syst√®me AI-Agent.

Ce script teste :
1. La correction de la s√©rialisation JSON dans database_persistence_service
2. La r√©cup√©ration du r√©pertoire de travail dans les n≈ìuds
3. La cr√©ation de PR apr√®s validation humaine
4. La configuration de logging Celery
"""

import asyncio
import json
import os
import tempfile
import logging
from unittest.mock import Mock, patch
from typing import Dict, Any

# Import des modules √† tester
from services.database_persistence_service import DatabasePersistenceService
from utils.helpers import get_working_directory, validate_working_directory, ensure_working_directory
from services.pull_request_service import pr_service
from services.logging_service import logging_service
from models.state import GraphState
from models.schemas import TaskRequest, TaskPriority, TaskType


def test_json_serialization():
    """Test la correction de la s√©rialisation JSON."""
    print("üß™ Test 1: S√©rialisation JSON corrig√©e")
    
    persistence = DatabasePersistenceService()
    
    # Test avec un dictionnaire normal
    normal_dict = {"test": "value", "number": 42}
    cleaned = persistence._clean_for_json_serialization(normal_dict)
    print(f"  ‚úÖ Dict normal: {cleaned}")
    
    # Test avec un objet complexe
    class ComplexObject:
        def __init__(self):
            self.attribute = "value"
            self.nested = {"inner": "data"}
    
    complex_obj = ComplexObject()
    cleaned_complex = persistence._clean_for_json_serialization(complex_obj)
    print(f"  ‚úÖ Objet complexe: {cleaned_complex}")
    
    # Test de s√©rialisation JSON compl√®te
    try:
        json_str = json.dumps(cleaned_complex)
        print(f"  ‚úÖ S√©rialisation JSON r√©ussie: {len(json_str)} caract√®res")
    except Exception as e:
        print(f"  ‚ùå Erreur s√©rialisation: {e}")
        return False
    
    print("  ‚úÖ Test s√©rialisation JSON: R√âUSSI\n")
    return True


def test_working_directory_recovery():
    """Test la r√©cup√©ration du r√©pertoire de travail."""
    print("üß™ Test 2: R√©cup√©ration du r√©pertoire de travail")
    
    # Cr√©er un r√©pertoire temporaire pour les tests
    with tempfile.TemporaryDirectory() as temp_dir:
        print(f"  üìÅ R√©pertoire temporaire cr√©√©: {temp_dir}")
        
        # Test 1: √âtat avec working_directory au niveau racine
        state1 = {
            "working_directory": temp_dir,
            "results": {}
        }
        
        wd1 = get_working_directory(state1)
        print(f"  ‚úÖ R√©cup√©ration niveau racine: {wd1}")
        assert wd1 == temp_dir, f"Expected {temp_dir}, got {wd1}"
        
        # Test 2: √âtat avec working_directory dans results
        state2 = {
            "results": {
                "working_directory": temp_dir,
                "prepare_result": {"working_directory": temp_dir}
            }
        }
        
        wd2 = get_working_directory(state2)
        print(f"  ‚úÖ R√©cup√©ration depuis results: {wd2}")
        assert wd2 == temp_dir, f"Expected {temp_dir}, got {wd2}"
        
        # Test 3: Validation du r√©pertoire
        is_valid = validate_working_directory(temp_dir, "test_node")
        print(f"  ‚úÖ Validation r√©pertoire: {is_valid}")
        assert is_valid, "Le r√©pertoire temporaire devrait √™tre valide"
        
        # Test 4: ensure_working_directory avec r√©cup√©ration
        state3 = {
            "results": {
                "prepare_result": {"working_directory": temp_dir}
            }
        }
        
        ensured_wd = ensure_working_directory(state3, "test_")
        print(f"  ‚úÖ R√©pertoire assur√©: {ensured_wd}")
        assert os.path.exists(ensured_wd), "Le r√©pertoire assur√© devrait exister"
    
    print("  ‚úÖ Test r√©cup√©ration r√©pertoire de travail: R√âUSSI\n")
    return True


async def test_pr_creation():
    """Test la cr√©ation de PR apr√®s validation."""
    print("üß™ Test 3: Cr√©ation de PR apr√®s validation")
    
    # Mock des outils GitHub
    with patch('nodes.merge_node.GitHubTool') as mock_github_tool:
        # Configurer le mock pour retourner un succ√®s
        mock_instance = Mock()
        # Le mock doit retourner une coroutine
        async def mock_arun(*args, **kwargs):
            return {
                "success": True,
                "pr_number": 123,
                "pr_url": "https://github.com/test/repo/pull/123"
            }
        mock_instance._arun = mock_arun
        mock_github_tool.return_value = mock_instance
        
        # Cr√©er un √©tat de test
        task_request = TaskRequest(
            task_id="test_task",
            title="Test PR Creation",
            description="Test description for PR creation",
            priority=TaskPriority.MEDIUM,
            task_type=TaskType.FEATURE,
            repository_url="https://github.com/test/repo"
        )
        
        # Cr√©er un r√©pertoire temporaire r√©el pour le test
        with tempfile.TemporaryDirectory() as temp_dir:
            state = GraphState(
                task=task_request,
                results={
                    "working_directory": temp_dir,
                    "git_result": {
                        "branch_name": "feature/test-branch"
                    },
                    "modified_files": ["test_file.py"],
                    "test_results": [{"success": True}],
                    "qa_results": {"overall_score": 85}
                }
            )
            
            # Tester la cr√©ation de PR
            result = await pr_service.ensure_pull_request_created(state)
            
            print(f"  ‚úÖ R√©sultat cr√©ation PR: {result}")
            assert result.success, f"La cr√©ation de PR devrait r√©ussir: {result.error}"
            assert result.pr_info.number == 123, "Le num√©ro de PR devrait √™tre 123"
            
            # V√©rifier les propri√©t√©s du PR cr√©√©
            assert result.pr_info.number == 123, "Le num√©ro de PR devrait √™tre 123"
            assert result.pr_info.url == "https://github.com/test/repo/pull/123", "L'URL devrait √™tre correcte"
            assert result.pr_info.branch == "feature/test-branch", "La branche devrait √™tre correcte"
        
    print("  ‚úÖ Test cr√©ation PR: R√âUSSI\n")
    return True


def test_celery_logging_config():
    """Test la configuration du logging Celery."""
    print("üß™ Test 4: Configuration du logging Celery")
    
    # Cr√©er un r√©pertoire temporaire pour les logs
    with tempfile.TemporaryDirectory() as temp_dir:
        # Changer temporairement le r√©pertoire de travail
        original_cwd = os.getcwd()
        os.chdir(temp_dir)
        
        try:
            # Tester la configuration du logging
            logging_service.setup_logging()
            
            # V√©rifier que le r√©pertoire logs a √©t√© cr√©√©
            logs_info = logging_service.get_logs_info()
            logs_dir = logs_info['logs_directory']
            assert os.path.exists(logs_dir), "Le r√©pertoire logs devrait √™tre cr√©√©"
            print(f"  ‚úÖ R√©pertoire logs cr√©√©: {logs_dir}")
            
            # V√©rifier que des handlers ont √©t√© cr√©√©s
            assert logs_info['handlers_count'] > 0, "Des handlers devraient √™tre cr√©√©s"
            print(f"  ‚úÖ Handlers cr√©√©s: {logs_info['handlers']}")
            
            # ‚úÖ NOUVEAU: V√©rifier le fichier logs.txt principal
            main_log_file = logs_info['main_log_file']
            assert main_log_file is not None, "Le fichier logs.txt devrait √™tre configur√©"
            print(f"  ‚úÖ Fichier logs.txt configur√©: {main_log_file}")
            
            # Tester qu'un logger existe et fonctionne
            logger = logging.getLogger('ai_agent_background')
            logger.info("Test message for logs.txt file")
            assert len(logger.handlers) > 0, "Le logger devrait avoir des handlers"
            print(f"  ‚úÖ Logger configur√© avec {len(logger.handlers)} handlers")
            
            # V√©rifier que le fichier logs.txt a √©t√© cr√©√©
            if os.path.exists(main_log_file):
                file_size = os.path.getsize(main_log_file)
                print(f"  ‚úÖ Fichier logs.txt cr√©√©: {file_size} bytes")
                
                # V√©rifier le contenu
                with open(main_log_file, 'r') as f:
                    content = f.read()
                    if "Test message for logs.txt file" in content:
                        print(f"  ‚úÖ Message de test trouv√© dans logs.txt")
                    else:
                        print(f"  ‚ö†Ô∏è Message de test non trouv√© dans logs.txt")
            else:
                print(f"  ‚ö†Ô∏è Fichier logs.txt non cr√©√© encore")
            
            # V√©rifier le fichier de m√©tadonn√©es
            metadata_file = os.path.join(logs_dir, "session_metadata.json")
            if os.path.exists(metadata_file):
                print(f"  ‚úÖ M√©tadonn√©es session cr√©√©es: {metadata_file}")
            else:
                print(f"  ‚ö†Ô∏è M√©tadonn√©es session non cr√©√©es (peut √™tre normal)")
            print(f"  ‚úÖ Configuration logging: OK")
            
        finally:
            os.chdir(original_cwd)
    
    print("  ‚úÖ Test configuration logging Celery: R√âUSSI\n")
    return True


def test_error_handling():
    """Test la gestion d'erreurs am√©lior√©e."""
    print("üß™ Test 5: Gestion d'erreurs am√©lior√©e")
    
    # Test 1: Validation de r√©pertoire inexistant
    fake_dir = "/path/that/does/not/exist"
    is_valid = validate_working_directory(fake_dir, "test_node")
    assert not is_valid, "Un r√©pertoire inexistant ne devrait pas √™tre valide"
    print(f"  ‚úÖ Validation r√©pertoire inexistant: {not is_valid}")
    
    # Test 2: get_working_directory avec √©tat vide
    empty_state = {}
    wd_empty = get_working_directory(empty_state)
    assert wd_empty is None, "√âtat vide devrait retourner None"
    print(f"  ‚úÖ √âtat vide: {wd_empty is None}")
    
    # Test 3: S√©rialisation d'objet non-s√©rialisable
    persistence = DatabasePersistenceService()
    
    class NonSerializable:
        def __init__(self):
            self.func = lambda x: x  # Les fonctions ne sont pas s√©rialisables
    
    non_ser = NonSerializable()
    cleaned = persistence._clean_for_json_serialization(non_ser)
    print(f"  ‚úÖ Objet non-s√©rialisable nettoy√©: {type(cleaned)}")
    
    # Le r√©sultat devrait √™tre un dict avec les attributs convertis
    assert isinstance(cleaned, dict), "Le r√©sultat devrait √™tre un dict"
    
    print("  ‚úÖ Test gestion d'erreurs: R√âUSSI\n")
    return True


async def main():
    """Fonction principale qui lance tous les tests."""
    print("üß™ D√âMARRAGE DES TESTS DE CORRECTION AI-AGENT")
    print("=" * 60)
    
    tests = [
        ("S√©rialisation JSON", test_json_serialization),
        ("R√©cup√©ration r√©pertoire de travail", test_working_directory_recovery),
        ("Cr√©ation PR", test_pr_creation),
        ("Configuration logging Celery", test_celery_logging_config),
        ("Gestion d'erreurs", test_error_handling),
    ]
    
    results = []
    
    for test_name, test_func in tests:
        try:
            if asyncio.iscoroutinefunction(test_func):
                result = await test_func()
            else:
                result = test_func()
            results.append((test_name, result))
        except Exception as e:
            print(f"  ‚ùå Erreur dans {test_name}: {e}")
            results.append((test_name, False))
    
    # R√©sum√© des r√©sultats
    print("=" * 60)
    print("üìä R√âSUM√â DES TESTS")
    print("=" * 60)
    
    passed = 0
    total = len(results)
    
    for test_name, result in results:
        status = "‚úÖ R√âUSSI" if result else "‚ùå √âCHOU√â"
        print(f"{test_name:.<50} {status}")
        if result:
            passed += 1
    
    print("=" * 60)
    print(f"üéØ R√âSULTAT GLOBAL: {passed}/{total} tests r√©ussis")
    
    if passed == total:
        print("üéâ TOUS LES TESTS SONT R√âUSSIS ! Les corrections sont fonctionnelles.")
        return True
    else:
        print("‚ö†Ô∏è Certains tests ont √©chou√©. V√©rifiez les corrections.")
        return False


if __name__ == "__main__":
    import sys
    success = asyncio.run(main())
    sys.exit(0 if success else 1) 